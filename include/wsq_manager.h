#ifndef __GSJ_WSQ_MANAGER_H_INCLUDE__
#define __GSJ_WSQ_MANAGER_H_INCLUDE__

/* Global variables*/
#include <global_var.h>

/* c c++ headers */
#include <vector>
#include <list>
#include <queue>        // std::queue
#include <stdlib.h>
#include <cstring>
#include <unistd.h>
#include <utility>
#include <chrono>       // std::chrono::seconds, std::chrono::milliseconds                    

/* External libs */
#include <geos/index/strtree/STRtree.h>
#include <geos/geom/Geometry.h>
#include <spdlog/spdlog.h>
#include <spdlog/cfg/env.h> // support for loading levels from the environment variable
#include <wsq.hpp>

namespace gsj{

template <typename T>
class WSQ_Manager{

	public:
		/**
		@brief constructs the wsq manager with a default capacity.

		@param capacity the default capacity of a queue (must be power of 2)
		*/
		explicit WSQ_Manager(ulong capacity = 1024);

		/**
		@brief destructs the wsq manager.
		*/
		~WSQ_Manager();

		/**
		@brief set the default capacity.
		*/
		void set_def_capcity(ulong capacity);

		/**
		@brief get the default capacity.
		*/
		ulong get_def_capcity(void);

		/**
		@brief return a pointer to a wsq with capacity of @param capacity.
		*/
		WorkStealingQueue<T>* WSQ_Init(ulong capacity);

		/**
		@brief return a pointer to a wsq with capacity of default capacity.
		*/
		WorkStealingQueue<T>* WSQ_Init(void);


		/**
		@brief return a pointer to an array of wsqs with capacity of @param capacity.
		*/
		WorkStealingQueue<T>** WSQ_Init_n_queues(uint num_queues, ulong capacity = 1024);

	private:
		/**
		@brief store wsqs generated by this wsq manager.
		*/
		//template <typename T>
		std::queue<WorkStealingQueue<T>*>* q_queue;

		/**
		@brief default capacity.
		*/
		ulong def_capcity;

};//class WSQ_Manager

// Constructor
template <typename T>
WSQ_Manager<T>::WSQ_Manager(ulong capacity) 
{
	if(capacity && (!(capacity & (capacity-1))))
	{
		def_capcity = capacity;
	}
	else
	{
		spdlog::info("Capacity queue has to be power of 2. Initilized as {0:d} instead of {1:d}", 1024, capacity);
		def_capcity = 1024;
	}

	q_queue = new std::queue<WorkStealingQueue<T>*>();
}

// Destructor
template <typename T>
WSQ_Manager<T>::~WSQ_Manager() 
{
	while(!q_queue->empty())
	{
		delete q_queue->front();
		q_queue->pop();
	}
	delete q_queue;
}

// Set defalue capacity
template <typename T>
void WSQ_Manager<T>::set_def_capcity(ulong capacity)
{
	if(capacity && (!(capacity & (capacity-1))))
	{
		def_capcity = capacity;
	}
	else
	{
		spdlog::info("Capacity queue has to be power of 2. Sed defalut capacity as {0:d} instead of {1:d}", 1024, capacity);
		def_capcity = 1024;
	}
}

// Get defalue capacity
template <typename T>
ulong WSQ_Manager<T>::get_def_capcity(void)
{
	return def_capcity;
}

// Return a pointer to a wsq
template <typename T>
WorkStealingQueue<T>* WSQ_Manager<T>::WSQ_Init(ulong capacity)
{
	ulong cap;
	if(capacity && (!(capacity & (capacity-1))))
	{
		cap = capacity;
	}
	else
	{
		spdlog::info("Capacity queue has to be power of 2. Initilized as {0:d} instead of {1:d}", def_capcity, capacity);
		cap = def_capcity;
	}

	WorkStealingQueue<T>* wsq = new WorkStealingQueue<T>(cap);
	q_queue->push(wsq);

	return wsq;
}

// Return a pointer to a wsq
template <typename T>
WorkStealingQueue<T>* WSQ_Manager<T>::WSQ_Init(void)
{
	WorkStealingQueue<T>* wsq = new WorkStealingQueue<T>(def_capcity);
	q_queue->push(wsq);

	return wsq;
}

// Return a pointer to wsqs
template <typename T>
WorkStealingQueue<T>** WSQ_Manager<T>::WSQ_Init_n_queues(uint num_queues, ulong capacity)
{
	ulong cap;
	uint i;

	if(capacity && (!(capacity & (capacity-1))))
	{
		cap = capacity;
	}
	else
	{
		spdlog::info("Capacity queue has to be power of 2. Initilized as {0:d} instead of {1:d}", def_capcity, capacity);
		cap = def_capcity;
	}

	WorkStealingQueue<T>** q_wsq = new WorkStealingQueue<T>*[num_queues];

	for(i = 0; i < num_queues; ++i)
	{
		q_wsq[i] = new WorkStealingQueue<T>(cap);
		q_queue->push(q_wsq[i]);
	}

	return q_wsq;
}
 

}//namespace gsj

#endif //ndef __GSJ_WSQ_MANAGER_H_INCLUDE__
